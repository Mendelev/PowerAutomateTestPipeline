trigger:
- main

pool:
  vmImage: windows-latest

# üëá Ajuste estes valores/vari√°veis (recomendo usar Variable Group e marcar segredos)
variables:
- group: TestSecretPowerAutomate   # <-- traz PP_ClientSecret como segredo
- name: PowerPlatformSPN
  value: Teste-Pipeline-PowerAutomate
- name: TargetEnvironmentUrl
  value: https://orgb94915f5.crm2.dynamics.com

# SPN usado s√≥ para discovery (n√£o secreto):
- name: PP_TenantId
  value: a91374ed-f750-4034-857f-03d6783934d8
- name: PP_AppId
  value: 4d8f1723-b528-4318-bd65-55bd38a7c554
# N√ÉO declare PP_ClientSecret no YAML

# Prefer√™ncias (opcional):
- name: PreferOwnerUpn
  value: ''
- name: NoAuthApiNames
  value: shared_msnweather
- name: ProvisionerUrl
  value: ''


steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true


# 2) Pega o ZIP mais recente
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solu√ß√£o'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 3) Gera o deployment.settings.json (EVs + CRs descobertos do ZIP)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      pac --version
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) (Idempotente) Carrega m√≥dulos Admin/Maker
- task: PowerShell@2
  displayName: 'Carregar m√≥dulos Power Platform'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Get-Module Microsoft.PowerApps.* | Format-Table Name,Version

# 5) üîé AUTO-DISCOVERY de connections + preenchimento de EVs
- task: PowerShell@2
  displayName: 'Auto-discovery de connections e preenchimento do settings (robusto, sem $$())'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'

      # --- caminhos/entrada ---
      $settingsPath = "$(DeploymentSettingsFile)"                # esta existe
      if (!(Test-Path $settingsPath)) { throw "Settings file n√£o encontrado: $settingsPath" }
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # Leia vari√°veis pela ENV (n√£o explode se n√£o existirem)
      $targetUrl    = $env:TargetEnvironmentUrl
      $targetName   = $env:TargetEnvironmentName    # opcional
      $preferUpn    = $env:PreferOwnerUpn           # opcional
      $provUrl      = $env:ProvisionerUrl           # opcional (n√£o usamos aqui)
      $noAuthList   = @()
      if ($env:NoAuthApiNames) { $noAuthList = $env:NoAuthApiNames.Split(';',[System.StringSplitOptions]::RemoveEmptyEntries) | ForEach-Object { $_.Trim() } }

      $tenant = $env:PP_TenantId
      $app    = $env:PP_AppId
      $secret = $env:PP_ClientSecret

      if ([string]::IsNullOrWhiteSpace($targetUrl)) { throw "TargetEnvironmentUrl (env) n√£o definido." }
      $targetUrl = $targetUrl.TrimEnd('/')

      # --- 1) EVs via EV_<SchemaName> ---
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })) {
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)) { continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = $val"
      }

      # --- 2) Login com SPN (cmdlets Admin) ---
      if ([string]::IsNullOrWhiteSpace($tenant) -or [string]::IsNullOrWhiteSpace($app) -or [string]::IsNullOrWhiteSpace($secret)) {
        throw "PP_TenantId / PP_AppId / PP_ClientSecret n√£o definidos (env). Defina para habilitar o discovery."
      }

      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID $tenant -ApplicationId $app -ClientSecret $secret | Out-Null

      # --- 3) Resolver ambiente (robusto) ---
      $envs = Get-AdminPowerAppEnvironment
      if(-not $envs){ throw "Nenhum ambiente retornado. Verifique permiss√µes do app (Power Platform Admin) OU adicione como Application user (System Administrator) no ambiente." }

      Write-Host "Ambientes vis√≠veis pelo SPN:"
      $envs | Select-Object EnvironmentName,DisplayName,Location | Format-Table

      $env = $null
      if(-not [string]::IsNullOrWhiteSpace($targetName)){
        $env = $envs | Where-Object { $_.EnvironmentName -eq $targetName } | Select-Object -First 1
        if($env){ Write-Host "Encontrado por TargetEnvironmentName: $($env.EnvironmentName) / $($env.DisplayName)" }
      }
      if(-not $env){
        $host = ([Uri]$targetUrl).Host
        foreach($e in $envs){
          $lem = $e.Properties.linkedEnvironmentMetadata
          if(-not $lem){ continue }
          $lemJson = ($lem | ConvertTo-Json -Depth 10)
          if($lemJson -match [Regex]::Escape($host)){ $env = $e; break }
        }
      }
      if(-not $env){
        foreach($e in $envs){
          $lem = $e.Properties.linkedEnvironmentMetadata
          if(-not $lem){ continue }
          $cands = @($lem.instanceUrl,$lem.baseApiUrl,$lem.organizationUrl,$lem.instancesApiUrl,$lem.dataverseUrl) | Where-Object { $_ }
          if($cands | Where-Object { $_.ToString().TrimEnd('/') -eq $targetUrl }) { $env = $e; break }
        }
      }
      if(-not $env){
        Write-Warning "N√£o achei ambiente pelo URL: $targetUrl"
        Write-Host "Dica: defina TargetEnvironmentName (env var) ex.: 'Default-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'."
        throw "Environment n√£o encontrado. Revise URL, tenant (PP_TenantId) e permiss√µes do app."
      }

      $envName = $env.EnvironmentName
      Write-Host "Environment resolvido: $envName / $($env.DisplayName)"

      # --- 4) Bind das Connection References ---
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })) {
        if($cr.ConnectionId){ Write-Host "CR [$($cr.LogicalName)] j√° tem ConnectionId."; continue }

        # override via CR_<LogicalName>
        $override = [Environment]::GetEnvironmentVariable(("CR_{0}" -f $cr.LogicalName), 'Process')
        if($override){
          $cr.ConnectionId = $override
          Write-Host "CR [$($cr.LogicalName)] = $override (pr√©-definido)"
          continue
        }

        # apiName
        $apiName = $null
        if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId) { $apiName = ($cr.ConnectorId -split '/')[-1] }
        elseif ($cr.PSObject.Properties.Name -contains 'ApiName' -and $cr.ApiName)     { $apiName = $cr.ApiName }
        if([string]::IsNullOrWhiteSpace($apiName)){ Write-Warning "Sem apiName p/ CR [$($cr.LogicalName)]"; continue }

        $conns = Get-AdminPowerAppConnection -EnvironmentName $envName -ConnectorName $apiName -ErrorAction SilentlyContinue
        if(-not $conns){
          Write-Warning "Nenhuma connection encontrada para $apiName no ambiente $envName."
          continue
        }

        $chosen = $null
        if($preferUpn){ $chosen = $conns | Where-Object { $_.Status -eq 'Connected' -and $_.CreatedBy.userPrincipalName -eq $preferUpn } | Select-Object -First 1 }
        if(-not $chosen){ $chosen = $conns | Where-Object { $_.Status -eq 'Connected' } | Select-Object -First 1 }
        if(-not $chosen){ $chosen = $conns | Select-Object -First 1 }

        if($chosen){
          $cr.ConnectionId = $chosen.Name  # GUID
          Write-Host "CR [$($cr.LogicalName)] -> $apiName = $($cr.ConnectionId) ($($chosen.Status))"
        } else {
          Write-Warning "Connections existem para $apiName, mas nenhuma selecionada."
        }
      }

      # --- 5) Salvar e validar pend√™ncias (compat√≠vel com PS 5.1) ---
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      $missing = @($json.ConnectionReferences | Where-Object { -not $_.ConnectionId })
      if($missing.Count -gt 0){
        $labels = @()
        foreach($m in $missing){
          $api = $null
          if ($m.PSObject.Properties.Name -contains 'ApiName' -and $m.ApiName) {
            $api = $m.ApiName
          } elseif ($m.PSObject.Properties.Name -contains 'ConnectorId' -and $m.ConnectorId) {
            $api = ($m.ConnectorId -split '/')[-1]
          } else { $api = '<api-desconhecida>' }
          $labels += ("{0} [{1}]" -f $api, $m.LogicalName)
        }
        $list = ($labels -join '; ')
        throw "Ainda faltam connections para: $list. Crie 1 por conector OU defina CR_<LogicalName> nas vari√°veis e rode novamente."
      } else {
        Write-Host "Todas as Connection References foram resolvidas."
      }


# 6) Importa usando o settings
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false

# 7) (Opcional) Ativar fluxos ‚Äî pode reaproveitar este bloco mais tarde
# Basta preencher PP_TenantId, PP_AppId, PP_ClientSecret (j√° est√£o a√≠)
- task: PowerShell@2
  displayName: 'Ativar fluxos (opcional)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID "$(PP_TenantId)" -ApplicationId "$(PP_AppId)" -ClientSecret "$(PP_ClientSecret)" | Out-Null
      $env = Get-AdminPowerAppEnvironment | Where-Object { $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq "$(TargetEnvironmentUrl)" } | Select-Object -First 1
      if(-not $env){ throw "Env n√£o encontrado: $(TargetEnvironmentUrl)" }
      $flows = Get-AdminFlow -EnvironmentName $env.EnvironmentName
      foreach($f in $flows){
        try{ Enable-AdminFlow -EnvironmentName $env.EnvironmentName -FlowName $f.FlowName -ErrorAction Stop; Write-Host "Ligado: $($f.DisplayName)" }
        catch{ Write-Warning "N√£o liguei $($f.DisplayName): $($_.Exception.Message)" }
      }
