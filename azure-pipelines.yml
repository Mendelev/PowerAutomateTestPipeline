trigger:
- main

pool:
  vmImage: windows-latest   # pode ser ubuntu-latest também

steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true     # deixa 'pac' acessível nas próximas etapas

# 2) Seleciona o ZIP mais recente do repo e define $(SolutionZip)
- task: PowerShell@2
  displayName: 'Selecionar ZIP'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 3) Gera o deployment.settings.json (descobre EVs + CRs do ZIP)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC CLI)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      pac --version
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) Preenche automaticamente os valores a partir de variáveis do pipeline
#    Convenção:
#    - EV_<SchemaName>         -> EnvironmentVariables[].Value
#    - CR_<LogicalName>        -> ConnectionReferences[].ConnectionId
- task: PowerShell@2
  displayName: 'Preencher settings com variáveis do pipeline'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $path = "$(DeploymentSettingsFile)"
      $json = Get-Content $path -Raw | ConvertFrom-Json

      # EVs
      foreach($ev in $json.EnvironmentVariables){
        $schema = $ev.SchemaName
        $varName = "EV_{0}" -f $schema
        $val = [Environment]::GetEnvironmentVariable($varName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)){ continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = $val"
      }

      # Connection References
      foreach($cr in $json.ConnectionReferences){
        $logical = $cr.LogicalName
        $varName = "CR_{0}" -f $logical
        $connId = [Environment]::GetEnvironmentVariable($varName, 'Process')
        if([string]::IsNullOrWhiteSpace($connId)){ continue }
        $cr.ConnectionId = $connId
        Write-Host "CR [$logical] = $connId"
      }

      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $path -Encoding utf8
      Write-Host "Settings atualizado: $path"

# 5) Importa usando o settings file (faz o bind de EVs e CRs)
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: 'Teste-Pipeline-PowerAutomate'    # sua service connection Power Platform (WIF)
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false   # ON só nos upgrades, depois da 1ª instalação
