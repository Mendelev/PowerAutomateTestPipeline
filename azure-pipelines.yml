trigger:
- main

pool:
  vmImage: 'windows-latest'

# Unifique tudo no formato de lista e traga o secret do Variable Group
variables:
- group: TestSecretPowerAutomate          # PP_ClientSecret (secret) aqui
- name: PowerPlatformSPN
  value: 'Teste-Pipeline-PowerAutomate'
- name: TargetEnvironmentUrl
  value: 'https://orgb94915f5.crm2.dynamics.com'
- name: PP_TenantId
  value: 'a91374ed-f750-4034-857f-03d6783934d8'
- name: PP_AppId
  value: '4d8f1723-b528-4318-bd65-55bd38a7c554'
# (Opcional) você pode definir EVs no nível do pipeline como variables "EV_<SchemaName>"

steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true

# 2) Autenticar PAC com o SPN (sem cmdlets Admin)
- task: PowerShell@2
  displayName: 'PAC Auth (Service Principal)'
  env:
    PP_ClientSecret: $(PP_ClientSecret)   # vem do Variable Group (secret)
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $url    = "$(TargetEnvironmentUrl)"
      $appid  = "$(PP_AppId)"
      $tenant = "$(PP_TenantId)"
      $secret = $env:PP_ClientSecret
      if (-not $secret) { throw "PP_ClientSecret não definido (Variable Group?)" }
      pac --version
      pac auth create --name "ci-spn" --url $url --applicationId $appid --clientSecret $secret --tenant $tenant
      pac auth select --name "ci-spn"
      pac auth who

# 3) Pegar o ZIP mais recente do repo
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solução'
  inputs:
    targetType: 'inline'
    script: |
      $root  = "$(Build.SourcesDirectory)"
      $zips  = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 4) Gerar deployment.settings.json
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar $out" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 5) Preencher EVs e vincular Connection References a conexões existentes
- task: PowerShell@2
  displayName: 'Preencher EVs e vincular Connection References (existentes)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $settingsPath = "$(DeploymentSettingsFile)"
      $envUrl       = "$(TargetEnvironmentUrl)"

      if(!(Test-Path $settingsPath)){ throw "Settings file não encontrado: $settingsPath" }
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # --- EVs: EV_<SchemaName> vindas das variáveis de ambiente do job
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })) {
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)) { continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = (definida)"
      }

      # --- Overrides manuais: CR_<LogicalName> (opcional)
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })) {
        $logical = $cr.LogicalName
        $preConn = [Environment]::GetEnvironmentVariable(("CR_{0}" -f $logical), 'Process')
        if($preConn){
          $cr.ConnectionId = $preConn
          Write-Host "CR [$logical] = $preConn (definido por variável CR_)"
        }
      }

      # --- Descobrir conexões existentes com PAC (sem --json)
      # Observação: 'pac connection list' não suporta saída JSON em algumas versões.
      # Vamos capturar a saída em texto e extrair os resource-ids /apis/<apiName>/connections/<name>.
      $out = & pac connection list -e $envUrl 2>&1
      $txt = $out | Out-String
      if ($LASTEXITCODE -ne 0) {
        Write-Host $txt
        throw "Falha ao executar 'pac connection list'."
      }

      # Parser 1: pega resource-ids completos, p.ex.:
      # /providers/Microsoft.PowerApps/apis/shared_msnweather/connections/shared-msnweather-123
      $connObjs = New-Object System.Collections.ArrayList
      $ridPattern = '/providers/Microsoft\.PowerApps/apis/(?<api>[^/\s]+)/connections/(?<name>[^/\s]+)'
      foreach($m in [regex]::Matches($txt, $ridPattern)){
        [void]$connObjs.Add([pscustomobject]@{
          apiName      = $m.Groups['api'].Value
          name         = $m.Groups['name'].Value
          connectionId = $m.Value
        })
      }

      # Parser 2 (fallback): tabela em texto com "name" e "apiName" na mesma linha
      # Se não conseguiu nenhum RID, tenta construir o RID a partir de nome + api.
      if($connObjs.Count -eq 0){
        foreach($line in ($txt -split "`r?`n")){
          # Ex.: "shared-msnweather-123   shared_msnweather   Connected"
          if($line -match '^(?<name>\S+)\s+(?<api>shared_[a-z0-9_]+)\b'){
            $name = $Matches['name']
            $api  = $Matches['api']
            $rid  = "/providers/Microsoft.PowerApps/apis/$api/connections/$name"
            [void]$connObjs.Add([pscustomobject]@{
              apiName      = $api
              name         = $name
              connectionId = $rid
            })
          }
        }
      }

      if($connObjs.Count -eq 0){
        Write-Host "Saída do PAC:"
        Write-Host $txt
        throw "Não foi possível interpretar a saída do 'pac connection list'."
      }

      # Vincular cada Connection Reference pelo apiName
      $missing = @()
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ -and -not $_.ConnectionId })) {
        $apiName = $null
        if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId){
          $apiName = ($cr.ConnectorId -split '/apis/')[-1].Trim('/')
        } elseif($cr.PSObject.Properties.Name -contains 'ApiName' -and $cr.ApiName){
          $apiName = $cr.ApiName
        }

        if([string]::IsNullOrWhiteSpace($apiName)){
          Write-Warning "Não consegui inferir apiName para [$($cr.LogicalName)]"
          $missing += [PSCustomObject]@{ LogicalName = $cr.LogicalName; ApiName = "(desconhecido)" }
          continue
        }

        # pega a primeira conexão do mesmo apiName (se quiser, refine a seleção)
        $match = $connObjs | Where-Object { $_.apiName -eq $apiName } | Select-Object -First 1
        if($match){
          $cr.ConnectionId = $match.connectionId
          Write-Host "CR [$($cr.LogicalName)] -> $apiName = $($cr.ConnectionId)"
        } else {
          $missing += [PSCustomObject]@{ LogicalName = $cr.LogicalName; ApiName = $apiName }
        }
      }

      # Salva o settings atualizado
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      if($missing.Count -gt 0){
        $list = ($missing | ForEach-Object { "$($_.ApiName) [$($_.LogicalName)]" }) -join '; '
        throw "Não encontrei conexões para: $list. Crie-as no ambiente OU informe manualmente via 'CR_<LogicalName>' nas variáveis."
      } else {
        Write-Host "Todas as Connection References foram vinculadas a conexões existentes."
      }


# 6) Importar solução usando o settings preenchido
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false
