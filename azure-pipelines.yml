trigger:
- main

pool:
  vmImage: windows-latest

# üëá Ajuste estes valores/vari√°veis (recomendo usar Variable Group e marcar segredos)
variables:
  PowerPlatformSPN: 'Teste-Pipeline-PowerAutomate'     # nome da sua service connection Power Platform (WIF)
  TargetEnvironmentUrl: 'https://orgb94915f5.crm2.dynamics.com'

  # SPN com SECRET s√≥ para "discovery" via cmdlets Admin (Secure variables):
  PP_TenantId: ''      # GUID do tenant
  PP_AppId: ''         # Application (client) ID
  PP_ClientSecret: ''  # segredo (secure)

  # (Opcional) prefer√™ncias:
  PreferOwnerUpn: ''   # se voc√™ quer priorizar connections de um UPN espec√≠fico (ex.: conta de servi√ßo)
  NoAuthApiNames: 'shared_msnweather'   # conectores sem auth que podem ser criados automaticamente (se Flow provisionador estiver configurado)
  ProvisionerUrl: ''   # URL do seu Flow provisionador (HTTP) para criar connections "no-auth" (deixe vazio para n√£o tentar criar)

steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true

# 2) Pega o ZIP mais recente
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solu√ß√£o'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 3) Gera o deployment.settings.json (EVs + CRs descobertos do ZIP)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      pac --version
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) (Idempotente) Carrega m√≥dulos Admin/Maker
- task: PowerShell@2
  displayName: 'Carregar m√≥dulos Power Platform'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Get-Module Microsoft.PowerApps.* | Format-Table Name,Version

# 5) üîé AUTO-DISCOVERY de connections + preenchimento de EVs
- task: PowerShell@2
  displayName: 'Auto-discovery de connections e preenchimento do settings (adaptativo)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $settingsPath = "$(DeploymentSettingsFile)"
      $envUrl       = "$(TargetEnvironmentUrl)"
      $preferUpn    = "$(PreferOwnerUpn)"
      $provUrl      = "$(ProvisionerUrl)"
      $noAuthList   = "$(NoAuthApiNames)".Split(';',[System.StringSplitOptions]::RemoveEmptyEntries) | ForEach-Object { $_.Trim() }

      if(!(Test-Path $settingsPath)){ throw "Settings file n√£o encontrado: $settingsPath" }
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # --- 1) EVs via EV_<SchemaName> (sempre) ---
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })) {
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)) { continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = $val"
      }

      # Constr√≥i lista de CRs requeridos
      $required = @()
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })) {
        $logical = $cr.LogicalName
        $apiName = $null
        if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId) { $apiName = ($cr.ConnectorId -split '/')[-1] }
        elseif ($cr.PSObject.Properties.Name -contains 'ApiName' -and $cr.ApiName)     { $apiName = $cr.ApiName }
        if([string]::IsNullOrWhiteSpace($apiName)) { Write-Warning "N√£o consegui inferir apiName p/ CR [$logical]"; continue }
        $required += [PSCustomObject]@{ LogicalName = $logical; ApiName = $apiName }
      }

      # J√° aplicar overrides CR_<LogicalName>, se existirem
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })) {
        $logical = $cr.LogicalName
        $preConn = [Environment]::GetEnvironmentVariable(("CR_{0}" -f $logical), 'Process')
        if($preConn) {
          $cr.ConnectionId = $preConn
          Write-Host "CR [$logical] = $preConn (pr√©-definido por vari√°vel)"
        }
      }

      # --- 2) Caminho A: discovery via cmdlets Admin (se PP_* estiverem definidos) ---
      $tenant = "$(PP_TenantId)"; $app = "$(PP_AppId)"; $secret = "$(PP_ClientSecret)"
      $didDiscovery = $false
      if(-not [string]::IsNullOrWhiteSpace($tenant) -and -not [string]::IsNullOrWhiteSpace($app) -and -not [string]::IsNullOrWhiteSpace($secret)) {
        # Carrega m√≥dulos (idempotente)
        try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
        foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
          if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
        }
        Add-PowerAppsAccount -TenantID $tenant -ApplicationId $app -ClientSecret $secret | Out-Null

        $env = Get-AdminPowerAppEnvironment | Where-Object {
          $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq $envUrl -or
          $_.Properties.linkedEnvironmentMetadata.instanceUrl -like "$envUrl*"
        } | Select-Object -First 1
        if(-not $env) { throw "Environment n√£o encontrado por URL: $envUrl" }
        $envName = $env.EnvironmentName
        Write-Host "Discovery: usando Admin cmdlets no ambiente $envName"

        foreach($cr in ($json.ConnectionReferences | Where-Object { $_ -and -not $_.ConnectionId })) {
          $logical = $cr.LogicalName
          $apiName = ($cr.ConnectorId -split '/')[-1]
          $conns = Get-AdminPowerAppConnection -EnvironmentName $envName -ConnectorName $apiName -ErrorAction SilentlyContinue
          if($conns) {
            $chosen = $null
            if($preferUpn) { $chosen = $conns | Where-Object { $_.Status -eq 'Connected' -and $_.CreatedBy.userPrincipalName -eq $preferUpn } | Select-Object -First 1 }
            if(-not $chosen) { $chosen = $conns | Where-Object { $_.Status -eq 'Connected' } | Select-Object -First 1 }
            if(-not $chosen) { $chosen = $conns | Select-Object -First 1 }
            if($chosen) {
              $cr.ConnectionId = $chosen.Name
              Write-Host "CR [$logical] -> $apiName = $($cr.ConnectionId)"
            }
          }
        }
        $didDiscovery = $true
      } else {
        Write-Host "Discovery: PP_* n√£o definidos; pulando cmdlets Admin."
      }

      # --- 3) Caminho B: Flow provisionador (sem secret) para conectores 'no-auth' ---
      $canProvision = ([string]::IsNullOrWhiteSpace($provUrl) -eq $false) -and [Uri]::IsWellFormedUriString($provUrl,[UriKind]::Absolute)
      if($canProvision) { Write-Host "ProvisionerUrl ativo (no-auth apenas)." }
      $missing = @()

      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ -and -not $_.ConnectionId })) {
        $logical = $cr.LogicalName
        $apiName = ($cr.ConnectorId -split '/')[-1]
        if($canProvision -and ($noAuthList -contains $apiName)) {
          $body = @{
            targetEnvironmentUrl = $envUrl
            apiName              = $apiName
            connectionParams     = @{}                 # sem auth
            principalObjectId    = "$(ServicePrincipalObjectId)"
          } | ConvertTo-Json -Depth 5
          Write-Host "Provisionando conex√£o no-auth para [$logical] ($apiName)..."
          try{
            $resp = Invoke-RestMethod -Method POST -Uri $provUrl -Body $body -ContentType 'application/json'
            if($resp.connectionId) {
              $cr.ConnectionId = $resp.connectionId
              Write-Host "CR [$logical] -> criada: $($resp.connectionId)"
              continue
            } else {
              Write-Warning "Flow provisionador n√£o retornou connectionId p/ $apiName."
            }
          } catch {
            Write-Warning "Falha ao provisionar $apiName para [$logical]: $($_.Exception.Message)"
          }
        }
        if(-not $cr.ConnectionId) {
          $missing += [PSCustomObject]@{ LogicalName = $logical; ApiName = $apiName; Motivo = "Sem connection dispon√≠vel" }
        }
      }

      # Salva settings
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      if($missing.Count -gt 0) {
        Write-Host "Connections pendentes:"
        $missing | Format-Table
        $list = ($missing | ForEach-Object { "$($_.ApiName) [$($_.LogicalName)]" }) -join '; '
        throw "Crie 1 connection por conector OU defina CR_<LogicalName> nas vari√°veis OU habilite ProvisionerUrl/NoAuthApiNames: $list"
      } else {
        Write-Host "Todas as Connection References foram resolvidas."
      }


# 6) Importa usando o settings
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false

# 7) (Opcional) Ativar fluxos ‚Äî pode reaproveitar este bloco mais tarde
# Basta preencher PP_TenantId, PP_AppId, PP_ClientSecret (j√° est√£o a√≠)
- task: PowerShell@2
  displayName: 'Ativar fluxos (opcional)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID "$(PP_TenantId)" -ApplicationId "$(PP_AppId)" -ClientSecret "$(PP_ClientSecret)" | Out-Null
      $env = Get-AdminPowerAppEnvironment | Where-Object { $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq "$(TargetEnvironmentUrl)" } | Select-Object -First 1
      if(-not $env){ throw "Env n√£o encontrado: $(TargetEnvironmentUrl)" }
      $flows = Get-AdminFlow -EnvironmentName $env.EnvironmentName
      foreach($f in $flows){
        try{ Enable-AdminFlow -EnvironmentName $env.EnvironmentName -FlowName $f.FlowName -ErrorAction Stop; Write-Host "Ligado: $($f.DisplayName)" }
        catch{ Write-Warning "N√£o liguei $($f.DisplayName): $($_.Exception.Message)" }
      }
