trigger:
- main

pool:
  vmImage: 'windows-latest'

# Unifique tudo no formato de lista e traga o secret do Variable Group
variables:
- group: TestSecretPowerAutomate          # PP_ClientSecret (secret) aqui
- name: PowerPlatformSPN
  value: 'Teste-Pipeline-PowerAutomate'
- name: TargetEnvironmentUrl
  value: 'https://orgb94915f5.crm2.dynamics.com'
- name: PP_TenantId
  value: 'a91374ed-f750-4034-857f-03d6783934d8'
- name: PP_AppId
  value: '4d8f1723-b528-4318-bd65-55bd38a7c554'
# (Opcional) você pode definir EVs no nível do pipeline como variables "EV_<SchemaName>"

steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true

# 2) Autenticar PAC com o SPN (sem cmdlets Admin)
- task: PowerShell@2
  displayName: 'PAC Auth (Service Principal)'
  env:
    PP_ClientSecret: $(PP_ClientSecret)   # vem do Variable Group (secret)
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $url    = "$(TargetEnvironmentUrl)"
      $appid  = "$(PP_AppId)"
      $tenant = "$(PP_TenantId)"
      $secret = $env:PP_ClientSecret
      if (-not $secret) { throw "PP_ClientSecret não definido (Variable Group?)" }
      pac --version
      pac auth create --name "ci-spn" --url $url --applicationId $appid --clientSecret $secret --tenant $tenant
      pac auth select --name "ci-spn"
      pac auth who

# 3) Pegar o ZIP mais recente do repo
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solução'
  inputs:
    targetType: 'inline'
    script: |
      $root  = "$(Build.SourcesDirectory)"
      $zips  = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 4) Gerar deployment.settings.json
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar $out" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 5) Preencher EVs e vincular Connection References a conexões existentes
- task: PowerShell@2
  displayName: 'Preencher EVs e vincular Connection References (por variável)'
  env:
    CR_smarthis_sharedmsnweather_b8b93: $(CR_smarthis_sharedmsnweather_b8b93)   # <- injeta a var do VG
    CRAPI_shared_msnweather: $(CRAPI_shared_msnweather)                          # (opcional) 1 por conector
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $settingsPath = "$(DeploymentSettingsFile)"
      if(!(Test-Path $settingsPath)){ throw "Settings file não encontrado: $settingsPath" }

      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # helper para ler env var de modo case-insensitive
      function Get-EnvCI([string]$name){
        $v = [Environment]::GetEnvironmentVariable($name, 'Process')
        if ([string]::IsNullOrEmpty($v)) {
          $all = [Environment]::GetEnvironmentVariables('Process')
          foreach($k in $all.Keys){ if($k -ieq $name){ return $all[$k] } }
        }
        return $v
      }

      # EVs: EV_<SchemaName>
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })) {
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = Get-EnvCI $vName
        if([string]::IsNullOrWhiteSpace($val)) { continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = (definida)"
      }

      # CR via nome lógico: CR_<LogicalName>
      $missing = @()
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })) {
        if ($cr.ConnectionId) { continue }

        $logical = $cr.LogicalName
        $varName = "CR_{0}" -f $logical
        $raw     = Get-EnvCI $varName

        # Fallback por ApiName: CRAPI_<ApiName>
        if([string]::IsNullOrWhiteSpace($raw)){
          $apiName = $null
          if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId){
            $apiName = ($cr.ConnectorId -split '/apis/')[-1].Trim('/')
          } elseif ($cr.PSObject.Properties.Name -contains 'ApiName'){ $apiName = $cr.ApiName }
          if($apiName){
            $apiVar = "CRAPI_{0}" -f $apiName
            $raw = Get-EnvCI $apiVar
          }
        }

        if([string]::IsNullOrWhiteSpace($raw)) {
          $apiName = $apiName
          if(-not $apiName){
            if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId){
              $apiName = ($cr.ConnectorId -split '/apis/')[-1].Trim('/')
            } elseif ($cr.PSObject.Properties.Name -contains 'ApiName'){ $apiName = $cr.ApiName }
          }
          $missing += [PSCustomObject]@{ LogicalName = $logical; ApiName = ($apiName ?? '(desconhecido)'); VarName = $varName }
          continue
        }

        $cid = $raw
        if ($raw -match '/connections/(?<id>[^/\s]+)') { $cid = $Matches['id'] }

        if ([string]::IsNullOrWhiteSpace($cid)) {
          Write-Warning "Valor inválido em $varName"
          $missing += [PSCustomObject]@{ LogicalName = $logical; ApiName = $apiName; VarName = $varName }
        } else {
          $cr.ConnectionId = $cid
          Write-Host "CR [$logical] = $cid (via variável)"
        }
      }

      # Salvar
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      if($missing.Count -gt 0){
        Write-Host "`nFaltam ConnectionIds para:"
        $missing | Format-Table
        throw "Defina as variáveis acima e reexecute o pipeline."
      } else {
        Write-Host "Todas as Connection References foram vinculadas via variáveis."
      }


- task: PowerShell@2
  displayName: 'DEBUG: checar CR_* no env'
  env:
    CR_smarthis_sharedmsnweather_b8b93: $(CR_smarthis_sharedmsnweather_b8b93)
  inputs:
    targetType: 'inline'
    script: |
      "CR_smarthis_sharedmsnweather_b8b93 visível? " + [bool]($env:CR_smarthis_sharedmsnweather_b8b93)



- task: PowerShell@2
  displayName: 'DEBUG: mostrar ConnectionReferences resolvidas'
  inputs:
    targetType: 'inline'
    script: |
      $settingsPath = "$(DeploymentSettingsFile)"
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json
      $json.ConnectionReferences | Select-Object LogicalName, ConnectorId, ConnectionId | Format-Table




# 6) Importar solução usando o settings preenchido
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false
