trigger:
- main

pool:
  vmImage: windows-latest

# üëá Ajuste estes valores/vari√°veis (recomendo usar Variable Group e marcar segredos)
variables:
  PowerPlatformSPN: 'Teste-Pipeline-PowerAutomate'     # nome da sua service connection Power Platform (WIF)
  TargetEnvironmentUrl: 'https://orgb94915f5.crm2.dynamics.com'

  # SPN com SECRET s√≥ para "discovery" via cmdlets Admin (Secure variables):
  PP_TenantId: ''      # GUID do tenant
  PP_AppId: ''         # Application (client) ID
  PP_ClientSecret: ''  # segredo (secure)

  # (Opcional) prefer√™ncias:
  PreferOwnerUpn: ''   # se voc√™ quer priorizar connections de um UPN espec√≠fico (ex.: conta de servi√ßo)
  NoAuthApiNames: 'shared_msnweather'   # conectores sem auth que podem ser criados automaticamente (se Flow provisionador estiver configurado)
  ProvisionerUrl: ''   # URL do seu Flow provisionador (HTTP) para criar connections "no-auth" (deixe vazio para n√£o tentar criar)

steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true

# 2) Pega o ZIP mais recente
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solu√ß√£o'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 3) Gera o deployment.settings.json (EVs + CRs descobertos do ZIP)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      pac --version
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) (Idempotente) Carrega m√≥dulos Admin/Maker
- task: PowerShell@2
  displayName: 'Carregar m√≥dulos Power Platform'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Get-Module Microsoft.PowerApps.* | Format-Table Name,Version

# 5) üîé AUTO-DISCOVERY de connections + preenchimento de EVs
- task: PowerShell@2
  displayName: 'Auto-discovery de connections e preenchimento do settings'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $settingsPath = "$(DeploymentSettingsFile)"
      $envUrl = "$(TargetEnvironmentUrl)"
      if(!(Test-Path $settingsPath)){ throw "Settings file n√£o encontrado: $settingsPath" }

      # 5.1 Login com SPN (secret) s√≥ para consultar admin APIs
      $tenant = "$(PP_TenantId)"; $app = "$(PP_AppId)"; $secret = "$(PP_ClientSecret)"
      if([string]::IsNullOrWhiteSpace($tenant) -or [string]::IsNullOrWhiteSpace($app) -or [string]::IsNullOrWhiteSpace($secret)){
        throw "Defina PP_TenantId, PP_AppId e PP_ClientSecret (secure variables) para habilitar o discovery."
      }
      Add-PowerAppsAccount -TenantID $tenant -ApplicationId $app -ClientSecret $secret | Out-Null

      # 5.2 Resolve EnvironmentName pelo URL
      $env = Get-AdminPowerAppEnvironment | Where-Object {
        $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq $envUrl -or
        $_.Properties.linkedEnvironmentMetadata.instanceUrl -like "$envUrl*"
      } | Select-Object -First 1
      if(-not $env){ throw "Environment n√£o encontrado por URL: $envUrl" }
      $envName = $env.EnvironmentName
      Write-Host "Environment: $envName"

      # 5.3 Carrega JSON
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # 5.4 EVs via vari√°veis EV_<SchemaName> (opcional)
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })){
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)){ continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = $val"
      }

      # 5.5 Descoberta e bind das Connection References
      $preferUpn = "$(PreferOwnerUpn)"
      $noAuthList = "$(NoAuthApiNames)".Split(';',[System.StringSplitOptions]::RemoveEmptyEntries) | ForEach-Object { $_.Trim() }
      $provUrl = "$(ProvisionerUrl)"
      $canProvision = ([string]::IsNullOrWhiteSpace($provUrl) -eq $false) -and [Uri]::IsWellFormedUriString($provUrl,[UriKind]::Absolute)

      $missing = @()

      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })){
        $logical = $cr.LogicalName
        $apiName = $null
        if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId){
          $apiName = ($cr.ConnectorId -split '/')[-1]
        } elseif ($cr.PSObject.Properties.Name -contains 'ApiName' -and $cr.ApiName){
          $apiName = $cr.ApiName
        }
        if([string]::IsNullOrWhiteSpace($apiName)){ Write-Warning "N√£o consegui inferir apiName para CR [$logical]"; continue }

        # Se j√° existir ConnectionId no settings, mant√©m
        if($cr.ConnectionId){ Write-Host "CR [$logical] j√° tem ConnectionId."; continue }

        # Descobre connections existentes para esse conector
        $conns = Get-AdminPowerAppConnection -EnvironmentName $envName -ConnectorName $apiName -ErrorAction SilentlyContinue
        if($conns){
          $chosen = $null
          if($preferUpn){
            $chosen = $conns | Where-Object { $_.Status -eq 'Connected' -and $_.CreatedBy.userPrincipalName -eq $preferUpn } | Select-Object -First 1
          }
          if(-not $chosen){ $chosen = $conns | Where-Object { $_.Status -eq 'Connected' } | Select-Object -First 1 }
          if(-not $chosen){ $chosen = $conns | Select-Object -First 1 }
          if($chosen){
            $cr.ConnectionId = $chosen.Name  # GUID
            Write-Host "CR [$logical] -> $apiName = $($cr.ConnectionId) ($($chosen.Status))"
            continue
          }
        }

        # Se n√£o achou connection: tentar criar se conector estiver na lista "no-auth"
        if($canProvision -and ($noAuthList -contains $apiName)){
          $body = @{
            targetEnvironmentUrl = $envUrl
            apiName              = $apiName
            connectionParams     = @{}                 # sem auth
            principalObjectId    = $(ServicePrincipalObjectId)
          } | ConvertTo-Json -Depth 5

          Write-Host "Provisionando connection no-auth para [$logical] ($apiName)..."
          try{
            $resp = Invoke-RestMethod -Method POST -Uri $provUrl -Body $body -ContentType 'application/json'
            if($resp.connectionId){
              $cr.ConnectionId = $resp.connectionId
              Write-Host "CR [$logical] -> criada: $($resp.connectionId)"
              continue
            } else {
              Write-Warning "Flow provisionador n√£o retornou connectionId para $apiName."
            }
          } catch {
            Write-Warning "Falha ao provisionar $apiName para [$logical]: $($_.Exception.Message)"
          }
        }

        # Ainda faltando
        $missing += [PSCustomObject]@{ LogicalName = $logical; ApiName = $apiName; Motivo = "Sem connection dispon√≠vel" }
      }

      # Salva settings
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      if($missing.Count -gt 0){
        Write-Host "Connections pendentes:"
        $missing | Format-Table
        $list = ($missing | ForEach-Object { "$($_.ApiName) [$($_.LogicalName)]" }) -join '; '
        throw "Crie 1 connection por conector listado OU defina CR_<LogicalName> nas vari√°veis e rode de novo: $list"
      } else {
        Write-Host "Todas as Connection References foram resolvidas."
      }

# 6) Importa usando o settings
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false

# 7) (Opcional) Ativar fluxos ‚Äî pode reaproveitar este bloco mais tarde
# Basta preencher PP_TenantId, PP_AppId, PP_ClientSecret (j√° est√£o a√≠)
- task: PowerShell@2
  displayName: 'Ativar fluxos (opcional)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID "$(PP_TenantId)" -ApplicationId "$(PP_AppId)" -ClientSecret "$(PP_ClientSecret)" | Out-Null
      $env = Get-AdminPowerAppEnvironment | Where-Object { $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq "$(TargetEnvironmentUrl)" } | Select-Object -First 1
      if(-not $env){ throw "Env n√£o encontrado: $(TargetEnvironmentUrl)" }
      $flows = Get-AdminFlow -EnvironmentName $env.EnvironmentName
      foreach($f in $flows){
        try{ Enable-AdminFlow -EnvironmentName $env.EnvironmentName -FlowName $f.FlowName -ErrorAction Stop; Write-Host "Ligado: $($f.DisplayName)" }
        catch{ Write-Warning "N√£o liguei $($f.DisplayName): $($_.Exception.Message)" }
      }
