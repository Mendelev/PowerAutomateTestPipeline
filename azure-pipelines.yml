trigger:
- main

pool:
  vmImage: windows-latest

# üëá Ajuste estes valores/vari√°veis (recomendo usar Variable Group e marcar segredos)
variables:
- group: TestSecretPowerAutomate   # <-- traz PP_ClientSecret como segredo
- name: PowerPlatformSPN
  value: Teste-Pipeline-PowerAutomate
- name: TargetEnvironmentUrl
  value: https://orgb94915f5.crm2.dynamics.com

# SPN usado s√≥ para discovery (n√£o secreto):
- name: PP_TenantId
  value: a91374ed-f750-4034-857f-03d6783934d8
- name: PP_AppId
  value: 4d8f1723-b528-4318-bd65-55bd38a7c554
# N√ÉO declare PP_ClientSecret no YAML

# Prefer√™ncias (opcional):
- name: PreferOwnerUpn
  value: ''
- name: NoAuthApiNames
  value: shared_msnweather
- name: ProvisionerUrl
  value: ''


steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true


# 2) Pega o ZIP mais recente
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solu√ß√£o'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 3) Gera o deployment.settings.json (EVs + CRs descobertos do ZIP)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      pac --version
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) (Idempotente) Carrega m√≥dulos Admin/Maker
- task: PowerShell@2
  displayName: 'Carregar m√≥dulos Power Platform'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Get-Module Microsoft.PowerApps.* | Format-Table Name,Version

# 5) üîé AUTO-DISCOVERY de connections + preenchimento de EVs
- task: PowerShell@2
  displayName: 'Bind de connections via Flow (sem Admin cmdlets)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'

      $settingsPath = "$(DeploymentSettingsFile)"
      if (!(Test-Path $settingsPath)) { throw "Settings file n√£o encontrado: $settingsPath" }
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      $provUrl = $env:ProvisionerUrl
      $envUrl  = $env:TargetEnvironmentUrl
      $spObjId = $env:ServicePrincipalObjectId  # opcional, use se o Flow fizer compartilhamento

      if ([string]::IsNullOrWhiteSpace($provUrl)) { throw "ProvisionerUrl (env) n√£o definido." }
      if (-not [Uri]::IsWellFormedUriString($provUrl, [UriKind]::Absolute)) { throw "ProvisionerUrl inv√°lido: $provUrl" }
      if ([string]::IsNullOrWhiteSpace($envUrl)) { throw "TargetEnvironmentUrl (env) n√£o definido." }

      # 1) EVs via EV_<SchemaName>
      if ($json.EnvironmentVariables) {
        foreach($ev in $json.EnvironmentVariables){
          if(-not $ev){ continue }
          $schema = $ev.SchemaName
          $vName  = "EV_{0}" -f $schema
          $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
          if([string]::IsNullOrWhiteSpace($val)) { continue }
          $ev.Value = $val
          Write-Host "EV [$schema] = $val"
        }
      }

      # 2) Lista de CRs sem ConnectionId (respeita overrides CR_<LogicalName>)
      $needed = @()
      foreach($cr in $json.ConnectionReferences){
        if(-not $cr){ continue }
        if($cr.ConnectionId){ continue }

        $override = [Environment]::GetEnvironmentVariable(("CR_{0}" -f $cr.LogicalName), 'Process')
        if($override){
          $cr.ConnectionId = $override
          Write-Host "CR [$($cr.LogicalName)] override = $override"
          continue
        }

        # Inferir apiName
        $apiName = $null
        if ($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId) { $apiName = ($cr.ConnectorId -split '/')[-1] }
        elseif ($cr.PSObject.Properties.Name -contains 'ApiName' -and $cr.ApiName)     { $apiName = $cr.ApiName }

        if ([string]::IsNullOrWhiteSpace($apiName)) {
          Write-Warning "N√£o consegui inferir apiName p/ CR [$($cr.LogicalName)]"
          continue
        }

        $needed += [PSCustomObject]@{ logicalName = $cr.LogicalName; apiName = $apiName }
      }

      if ($needed.Count -gt 0) {
        # 3) Chama o Flow provisionador
        $payload = @{
          targetEnvironmentUrl = $envUrl
          principalObjectId    = $spObjId   # se seu Flow usar; sen√£o, pode omitir
          connectors           = $needed     # [{ logicalName, apiName }]
        } | ConvertTo-Json -Depth 6

        Write-Host "POST $provUrl"
        $resp = Invoke-RestMethod -Method POST -Uri $provUrl -ContentType 'application/json' -Body $payload

        # Esperado: { bindings:[{logicalName,apiName,connectionId}], missing:[{logicalName,apiName,reason}] }
        $bindings = @()
        if ($resp -and $resp.PSObject.Properties.Name -contains 'bindings' -and $resp.bindings) { $bindings = @($resp.bindings) }

        foreach($b in $bindings){
          $cr = $json.ConnectionReferences | Where-Object { $_.LogicalName -eq $b.logicalName } | Select-Object -First 1
          if($cr){
            $cr.ConnectionId = $b.connectionId
            Write-Host "CR [$($b.logicalName)] <- $($b.connectionId)"
          }
        }

        $missing = @()
        if ($resp -and $resp.PSObject.Properties.Name -contains 'missing' -and $resp.missing) { $missing = @($resp.missing) }

        if ($missing.Count -gt 0){
          Write-Host "Connections pendentes (Flow reportou 'missing'):"
          $labels = @()
          foreach($m in $missing){
            $reason = $m.reason
            if ([string]::IsNullOrWhiteSpace($reason)) { $reason = 'unknown' }
            $labels += ("{0} [{1}] - {2}" -f $m.apiName, $m.logicalName, $reason)
          }
          $list = ($labels -join '; ')
          throw "Ainda faltam connections: $list. Crie uma connection no ambiente OU passe CR_<LogicalName> como vari√°vel e rode de novo."
        }
      } else {
        Write-Host "Nenhuma Connection Reference pendente."
      }

      # 4) Salva settings
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"



# 6) Importa usando o settings
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false

# 7) (Opcional) Ativar fluxos ‚Äî pode reaproveitar este bloco mais tarde
# Basta preencher PP_TenantId, PP_AppId, PP_ClientSecret (j√° est√£o a√≠)
- task: PowerShell@2
  displayName: 'Ativar fluxos (opcional)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID "$(PP_TenantId)" -ApplicationId "$(PP_AppId)" -ClientSecret "$(PP_ClientSecret)" | Out-Null
      $env = Get-AdminPowerAppEnvironment | Where-Object { $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq "$(TargetEnvironmentUrl)" } | Select-Object -First 1
      if(-not $env){ throw "Env n√£o encontrado: $(TargetEnvironmentUrl)" }
      $flows = Get-AdminFlow -EnvironmentName $env.EnvironmentName
      foreach($f in $flows){
        try{ Enable-AdminFlow -EnvironmentName $env.EnvironmentName -FlowName $f.FlowName -ErrorAction Stop; Write-Host "Ligado: $($f.DisplayName)" }
        catch{ Write-Warning "N√£o liguei $($f.DisplayName): $($_.Exception.Message)" }
      }
