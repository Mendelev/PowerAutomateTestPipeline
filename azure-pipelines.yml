trigger:
- main

pool:
  vmImage: 'windows-latest'

# Unifique tudo no formato de lista e traga o secret do Variable Group
variables:
- group: TestSecretPowerAutomate          # PP_ClientSecret (secret) aqui
- name: PowerPlatformSPN
  value: 'Teste-Pipeline-PowerAutomate'
- name: TargetEnvironmentUrl
  value: 'https://orgb94915f5.crm2.dynamics.com'
- name: PP_TenantId
  value: 'a91374ed-f750-4034-857f-03d6783934d8'
- name: PP_AppId
  value: '4d8f1723-b528-4318-bd65-55bd38a7c554'
# (Opcional) você pode definir EVs no nível do pipeline como variables "EV_<SchemaName>"

steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true

# 2) Autenticar PAC com o SPN (sem cmdlets Admin)
- task: PowerShell@2
  displayName: 'PAC Auth (Service Principal)'
  env:
    PP_ClientSecret: $(PP_ClientSecret)   # vem do Variable Group (secret)
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $url    = "$(TargetEnvironmentUrl)"
      $appid  = "$(PP_AppId)"
      $tenant = "$(PP_TenantId)"
      $secret = $env:PP_ClientSecret
      if (-not $secret) { throw "PP_ClientSecret não definido (Variable Group?)" }
      pac --version
      pac auth create --name "ci-spn" --url $url --applicationId $appid --clientSecret $secret --tenant $tenant
      pac auth select --name "ci-spn"
      pac auth who

# 3) Pegar o ZIP mais recente do repo
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solução'
  inputs:
    targetType: 'inline'
    script: |
      $root  = "$(Build.SourcesDirectory)"
      $zips  = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 4) Gerar deployment.settings.json
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar $out" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 5) Preencher EVs e vincular Connection References a conexões existentes
# 5) Preencher EVs e vincular Connection References via CR_<LogicalName>
- task: PowerShell@2
  displayName: 'Preencher EVs e vincular Connection References (por variável)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $settingsPath = "$(DeploymentSettingsFile)"
      if(!(Test-Path $settingsPath)){ throw "Settings file não encontrado: $settingsPath" }

      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # --- EVs: EV_<SchemaName> vindas das variáveis de ambiente do job
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })) {
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)) { continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = (definida)"
      }

      # --- Connection References: usar CR_<LogicalName>
      $missing = @()
      # --- Fallback por ApiName: CRAPI_<ApiName>, ex.: CRAPI_shared_msnweather
      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ -and -not $_.ConnectionId })) {
        $apiName = $null
        if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId){
          $apiName = ($cr.ConnectorId -split '/apis/')[-1].Trim('/')
        } elseif ($cr.PSObject.Properties.Name -contains 'ApiName') { $apiName = $cr.ApiName }        
        if([string]::IsNullOrWhiteSpace($apiName)){ continue }        
        $apiVar = "CRAPI_{0}" -f $apiName
        $raw    = [Environment]::GetEnvironmentVariable($apiVar, 'Process')
        if([string]::IsNullOrWhiteSpace($raw)){ continue }        
        $cid = $raw
        if ($raw -match '/connections/(?<id>[^/\s]+)') { $cid = $Matches['id'] }
        if ([string]::IsNullOrWhiteSpace($cid)) { continue }        
        $cr.ConnectionId = $cid
        Write-Host "CR [$($cr.LogicalName)] = $cid (via $apiVar)"
      }


      # Salvar o settings atualizado
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      if($missing.Count -gt 0){
        Write-Host "`nFaltam ConnectionIds para os CRs abaixo:"
        $missing | Format-Table
        Write-Host "`nDefina no Variable Group (exemplos):"
        foreach($m in $missing){
          $example = "/providers/Microsoft.PowerApps/apis/$($m.ApiName)/connections/<id-da-sua-conexao>"
          Write-Host "  $($m.VarName) = <GUID ou '$example'>"
        }
        throw "Defina as variáveis acima e reexecute o pipeline."
      } else {
        Write-Host "Todas as Connection References foram vinculadas via CR_<LogicalName>."
      }





# 6) Importar solução usando o settings preenchido
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false
