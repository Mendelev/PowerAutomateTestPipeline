trigger:
- main

pool:
  vmImage: windows-latest

# üëá Ajuste estes valores/vari√°veis (recomendo usar Variable Group e marcar segredos)
variables:
- group: TestSecretPowerAutomate   # <-- traz PP_ClientSecret como segredo
- name: PowerPlatformSPN
  value: Teste-Pipeline-PowerAutomate
- name: TargetEnvironmentUrl
  value: https://orgb94915f5.crm2.dynamics.com

# SPN usado s√≥ para discovery (n√£o secreto):
- name: PP_TenantId
  value: a91374ed-f750-4034-857f-03d6783934d8
- name: PP_AppId
  value: 4d8f1723-b528-4318-bd65-55bd38a7c554
# N√ÉO declare PP_ClientSecret no YAML

# Prefer√™ncias (opcional):
- name: PreferOwnerUpn
  value: ''
- name: NoAuthApiNames
  value: shared_msnweather
- name: ProvisionerUrl
  value: ''


steps:
# 1) PAC no PATH
- task: PowerPlatformToolInstaller@2
  displayName: 'Power Platform Tool Installer'
  inputs:
    DefaultVersion: true
    AddToolsToPath: true


# 2) Pega o ZIP mais recente
- task: PowerShell@2
  displayName: 'Selecionar ZIP da solu√ß√£o'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado em $root" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      $dest = Join-Path "$(Build.ArtifactStagingDirectory)" "solution.zip"
      Copy-Item $picked $dest -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$dest"
      Write-Host "Selecionado: $picked -> $dest"

# 3) Gera o deployment.settings.json (EVs + CRs descobertos do ZIP)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      pac --version
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)/deployment.settings.json"
      pac solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) (Idempotente) Carrega m√≥dulos Admin/Maker
- task: PowerShell@2
  displayName: 'Carregar m√≥dulos Power Platform'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Get-Module Microsoft.PowerApps.* | Format-Table Name,Version

# 5) üîé AUTO-DISCOVERY de connections + preenchimento de EVs
- task: PowerShell@2
  displayName: 'Auto-discovery de connections e preenchimento do settings (robusto)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'

      $settingsPath = "$(DeploymentSettingsFile)"
      if(!(Test-Path $settingsPath)){ throw "Settings file n√£o encontrado: $settingsPath" }
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # ----- 1) Preencher EVs por vari√°veis EV_<SchemaName> -----
      foreach($ev in ($json.EnvironmentVariables | Where-Object { $_ })) {
        $schema = $ev.SchemaName
        $vName  = "EV_{0}" -f $schema
        $val    = [Environment]::GetEnvironmentVariable($vName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)) { continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = $val"
      }

      # ----- 2) Login com SPN para discovery (Admin cmdlets) -----
      $tenant = "$(PP_TenantId)"; $app = "$(PP_AppId)"; $secret = "$(PP_ClientSecret)"
      if([string]::IsNullOrWhiteSpace($tenant) -or [string]::IsNullOrWhiteSpace($app) -or [string]::IsNullOrWhiteSpace($secret)){
        throw "PP_* n√£o definidos. Para o modo discovery, defina PP_TenantId, PP_AppId e PP_ClientSecret (secure)."
      }

      try { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop } catch {}
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID $tenant -ApplicationId $app -ClientSecret $secret | Out-Null

      # ----- 3) Resolver o ambiente (robusto) -----
      $targetUrl = "$(TargetEnvironmentUrl)".TrimEnd('/')
      $targetName = "$(TargetEnvironmentName)"  # opcional: ex. 'Default-12345678-...'
      $envs = Get-AdminPowerAppEnvironment

      if(-not $envs){ throw "Nenhum ambiente retornado. Verifique permiss√µes do app (Power Platform Administrator) OU adicione-o como Application user ao ambiente." }

      Write-Host "Ambientes vis√≠veis pelo SPN:"
      $envs | Select-Object EnvironmentName,DisplayName,Location | Format-Table

      $env = $null
      if(-not [string]::IsNullOrWhiteSpace($targetName)){
        $env = $envs | Where-Object { $_.EnvironmentName -eq $targetName } | Select-Object -First 1
        if($env){ Write-Host "Encontrado por TargetEnvironmentName: $($env.EnvironmentName) / $($env.DisplayName)" }
      }

      if(-not $env){
        # Normaliza host; tenta achar em qualquer campo do linkedEnvironmentMetadata
        $host = ([Uri]$targetUrl).Host
        foreach($e in $envs){
          $lem = $e.Properties.linkedEnvironmentMetadata
          if(-not $lem){ continue }
          # Converte propriedades em texto e tenta 'contains' do host
          $lemJson = ($lem | ConvertTo-Json -Depth 10)
          if($lemJson -match [Regex]::Escape($host)){
            $env = $e; break
          }
        }
      }

      if(-not $env){
        # √öltimo fallback: tente campos "comuns"
        foreach($e in $envs){
          $p = $e.Properties
          $candidatos = @()
          if($p -and $p.linkedEnvironmentMetadata){
            $lem = $p.linkedEnvironmentMetadata
            $candidatos += @(
              $lem.instanceUrl,
              $lem.baseApiUrl,
              $lem.organizationUrl,
              $lem.instancesApiUrl,
              $lem.dataverseUrl
            )
          }
          if($candidatos | Where-Object { $_ -and $_.ToString().TrimEnd('/') -eq $targetUrl }){
            $env = $e; break
          }
        }
      }

      if(-not $env){
        # Ajuda de diagn√≥stico
        Write-Warning "N√£o achei ambiente pelo URL: $targetUrl"
        Write-Host "Dica: informe TargetEnvironmentName para evitar ambiguidade (ex.: 'Default-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx')."
        throw "Environment n√£o encontrado. Revise: TargetEnvironmentUrl, tenant (PP_TenantId) e permiss√µes do app."
      }

      $envName = $env.EnvironmentName
      Write-Host "Environment resolvido: $envName / $($env.DisplayName)"

      # ----- 4) Fazer o bind das Connection References -----
      # Prefer√™ncia opcional: priorizar connections de um UPN espec√≠fico
      $preferUpn = "$(PreferOwnerUpn)"

      foreach($cr in ($json.ConnectionReferences | Where-Object { $_ })) {
        if($cr.ConnectionId){ Write-Host "CR [$($cr.LogicalName)] j√° tem ConnectionId."; continue }

        # Override por vari√°vel CR_<LogicalName>, se houver
        $override = [Environment]::GetEnvironmentVariable(("CR_{0}" -f $cr.LogicalName), 'Process')
        if($override){
          $cr.ConnectionId = $override
          Write-Host "CR [$($cr.LogicalName)] = $override (pr√©-definido)"
          continue
        }

        # Descobrir apiName
        $apiName = $null
        if($cr.PSObject.Properties.Name -contains 'ConnectorId' -and $cr.ConnectorId) { $apiName = ($cr.ConnectorId -split '/')[-1] }
        elseif ($cr.PSObject.Properties.Name -contains 'ApiName' -and $cr.ApiName)     { $apiName = $cr.ApiName }

        if([string]::IsNullOrWhiteSpace($apiName)){
          Write-Warning "N√£o consegui inferir apiName para CR [$($cr.LogicalName)]. Pulei."
          continue
        }

        $conns = Get-AdminPowerAppConnection -EnvironmentName $envName -ConnectorName $apiName -ErrorAction SilentlyContinue
        if(-not $conns){
          Write-Warning "Nenhuma connection encontrada para $apiName no ambiente $envName."
          continue
        }

        $chosen = $null
        if($preferUpn){
          $chosen = $conns | Where-Object { $_.Status -eq 'Connected' -and $_.CreatedBy.userPrincipalName -eq $preferUpn } | Select-Object -First 1
        }
        if(-not $chosen){ $chosen = $conns | Where-Object { $_.Status -eq 'Connected' } | Select-Object -First 1 }
        if(-not $chosen){ $chosen = $conns | Select-Object -First 1 }

        if($chosen){
          $cr.ConnectionId = $chosen.Name  # GUID da connection
          Write-Host "CR [$($cr.LogicalName)] -> $apiName = $($cr.ConnectionId) ($($chosen.Status))"
        } else {
          Write-Warning "Connections existem para $apiName, mas nenhuma selecionada."
        }
      }

      # ----- 5) Salvar settings e validar pend√™ncias -----
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

      $missing = @($json.ConnectionReferences | Where-Object { -not $_.ConnectionId })
      if($missing.Count -gt 0){
        $list = ($missing | ForEach-Object { "$($_.ApiName ?? ($_.ConnectorId -split '/')[-1]) [$($_.LogicalName)]" }) -join '; '
        throw "Ainda faltam connections para: $list. Crie 1 por conector OU defina CR_<LogicalName> nas vari√°veis e rode novamente."
      } else {
        Write-Host "Todas as Connection References foram resolvidas."
      }


# 6) Importa usando o settings
- task: PowerPlatformImportSolution@2
  displayName: 'Import Solution (com settings)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '$(PowerPlatformSPN)'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false

# 7) (Opcional) Ativar fluxos ‚Äî pode reaproveitar este bloco mais tarde
# Basta preencher PP_TenantId, PP_AppId, PP_ClientSecret (j√° est√£o a√≠)
- task: PowerShell@2
  displayName: 'Ativar fluxos (opcional)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      foreach ($m in 'Microsoft.PowerApps.Administration.PowerShell','Microsoft.PowerApps.PowerShell'){
        if (Get-Module -ListAvailable -Name $m) { Import-Module $m -Force } else { Install-Module $m -Scope CurrentUser -Force -AllowClobber; Import-Module $m -Force }
      }
      Add-PowerAppsAccount -TenantID "$(PP_TenantId)" -ApplicationId "$(PP_AppId)" -ClientSecret "$(PP_ClientSecret)" | Out-Null
      $env = Get-AdminPowerAppEnvironment | Where-Object { $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq "$(TargetEnvironmentUrl)" } | Select-Object -First 1
      if(-not $env){ throw "Env n√£o encontrado: $(TargetEnvironmentUrl)" }
      $flows = Get-AdminFlow -EnvironmentName $env.EnvironmentName
      foreach($f in $flows){
        try{ Enable-AdminFlow -EnvironmentName $env.EnvironmentName -FlowName $f.FlowName -ErrorAction Stop; Write-Host "Ligado: $($f.DisplayName)" }
        catch{ Write-Warning "N√£o liguei $($f.DisplayName): $($_.Exception.Message)" }
      }
