trigger:
- main

pool:
  vmImage: 'windows-latest'

variables:
  # (Opcional) force overrides em caso de mais de uma connection para o mesmo connector
  # Formato: ConnectorName=ConnectionId;ConnectorName2=ConnectionId2
  CROverrides: ''  

steps:
# 1) Instala o PAC CLI (para gerar o settings) e módulos PowerShell
- task: PowerShell@2
  displayName: 'Instalar PAC CLI + módulos PowerShell'
  inputs:
    targetType: 'inline'
    script: |
      iwr https://aka.ms/powerplatform-vscode -UseBasicParsing -OutFile pac.msi
      Start-Process msiexec.exe -ArgumentList '/i pac.msi /qn' -Wait
      # Módulos PowerShell (Admin + Makers)
      Install-Module Microsoft.PowerApps.Administration.PowerShell -Force -Scope CurrentUser
      Install-Module Microsoft.PowerApps.PowerShell -Force -Scope CurrentUser

# 2) Escolhe o ZIP mais recente do repositório e salva como solution.zip
- task: PowerShell@2
  displayName: 'Selecionar o .zip da solução'
  inputs:
    targetType: 'inline'
    script: |
      $root = "$(Build.SourcesDirectory)"
      $zips = Get-ChildItem -Path $root -Recurse -Filter *.zip | Sort-Object LastWriteTime -Descending
      if(-not $zips){ throw "Nenhum .zip encontrado" }
      $picked = $zips[0].FullName
      New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
      Copy-Item $picked "$(Build.ArtifactStagingDirectory)\solution.zip" -Force
      Write-Host "##vso[task.setvariable variable=SolutionZip]$(Build.ArtifactStagingDirectory)\solution.zip"
      Write-Host "ZIP escolhido: $picked"

# 3) Gera o deployment.settings.json (EVs + ConnectionReferences)
- task: PowerShell@2
  displayName: 'Gerar deployment.settings.json (PAC CLI)'
  inputs:
    targetType: 'inline'
    script: |
      $zip = "$(SolutionZip)"
      $out = "$(Build.ArtifactStagingDirectory)\deployment.settings.json"
      & "$env:LOCALAPPDATA\Microsoft\PowerAppsCLI\pac.exe" solution create-settings --solution-zip $zip --settings-file $out
      if(!(Test-Path $out)){ throw "Falha ao gerar settings file" }
      Write-Host "##vso[task.setvariable variable=DeploymentSettingsFile]$out"
      Write-Host "Gerado: $out"

# 4) Puxa variáveis da sua Service Connection do Power Platform (para reuso no login)
- task: PowerPlatformSetConnectionVariables@2
  displayName: 'Set Connection Vars (Power Platform SPN)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: 'Teste-Pipeline-PowerAutomate'  # <-- sua service connection

# 5) AUTO-BIND das ConnectionReferences -> procura connections existentes e preenche o settings.json
- task: PowerShell@2
  displayName: 'Auto-bind ConnectionReferences no settings.json'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $settingsPath = "$(DeploymentSettingsFile)"
      $envUrl = "$(BuildTools.EnvironmentUrl)"  # vem da task SetConnectionVariables
      if(-not $envUrl){ $envUrl = "$(PowerPlatform.EnvironmentUrl)" }  # fallback
      
      # Login com o mesmo SPN da Service Connection
      $tenantId = "$(PowerPlatform.TenantId)"
      $appId    = "$(PowerPlatform.ApplicationId)"
      $secret   = "$(PowerPlatform.ClientSecret)"
      Add-PowerAppsAccount -TenantID $tenantId -ApplicationId $appId -ClientSecret $secret | Out-Null

      # Descobre o EnvironmentName a partir da URL
      $env = Get-AdminPowerAppEnvironment | Where-Object {
        $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq $envUrl -or
        $_.Properties.linkedEnvironmentMetadata.instanceUrl -like "$envUrl*"
      } | Select-Object -First 1
      if(-not $env){ throw "Não foi possível localizar o Environment pelo URL '$envUrl'." }
      $envName = $env.EnvironmentName
      Write-Host "EnvironmentName: $envName"

      # Carrega settings
      $json = Get-Content $settingsPath -Raw | ConvertFrom-Json

      # Overrides opcionais (ConnectorName=ConnectionId;...)
      $overridesRaw = "$(CROverrides)"
      $overrides = @{}
      if($overridesRaw){
        $overridesRaw.Split(';') | ForEach-Object {
          if($_ -match '='){
            $k,$v = $_.Split('=',2)
            $overrides[$k.Trim()] = $v.Trim()
          }
        }
      }

      # Para cada ConnectionReference -> preenche ConnectionId automaticamente
      foreach($cr in $json.ConnectionReferences){
        # O PAC coloca algo como "/providers/Microsoft.PowerApps/apis/shared_sharepointonline"
        $connectorName = ($cr.ConnectorId -split '/')[-1]
        
        if($overrides.ContainsKey($connectorName)){
          $cr.ConnectionId = $overrides[$connectorName]
          Write-Host "CR [$($cr.LogicalName)] -> override ($connectorName) = $($cr.ConnectionId)"
          continue
        }

        # Lista connections existentes desse connector no ambiente
        $conns = Get-AdminPowerAppConnection -ConnectorName $connectorName -EnvironmentName $envName
        if(-not $conns){
          Write-Warning "Nenhuma connection encontrada para '$connectorName' no ambiente '$envName'."
          continue
        }

        # Heurística: pega a primeira 'Connected'. Se quiser, adicione mais filtros (CreatedBy/Owner)
        $chosen = $conns | Where-Object { $_.Status -eq 'Connected' } | Select-Object -First 1
        if(-not $chosen){ $chosen = $conns | Select-Object -First 1 }

        if($chosen){
          # O id da connection é a propriedade Name
          $cr.ConnectionId = $chosen.Name
          Write-Host "CR [$($cr.LogicalName)] -> $connectorName = $($cr.ConnectionId) ($($chosen.Status))"
        } else {
          Write-Warning "Connections encontradas para '$connectorName', mas nenhuma selecionada."
        }
      }

      # (Opcional) Preencha EnvironmentVariables a partir de variáveis de pipeline:
      # Use naming convention: EV.<SchemaName>
      foreach($ev in $json.EnvironmentVariables){
        $schema = $ev.SchemaName
        $varName = "EV.$schema"
        $val = [Environment]::GetEnvironmentVariable($varName, 'Process')
        if([string]::IsNullOrWhiteSpace($val)){ continue }
        $ev.Value = $val
        Write-Host "EV [$schema] = $val"
      }

      # Salva
      $json | ConvertTo-Json -Depth 20 | Out-File -FilePath $settingsPath -Encoding utf8
      Write-Host "Settings atualizado: $settingsPath"

# 6) Importa a solução usando o settings file
- task: PowerPlatformImportSolution@2
  displayName: 'Importar solução (com settings file)'
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: 'Teste-Pipeline-PowerAutomate'
    SolutionInputFile: '$(SolutionZip)'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(DeploymentSettingsFile)'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
    StageAndUpgrade: false

# 7) Liga os fluxos da solução (Enable-AdminFlow)
- task: PowerShell@2
  displayName: 'Ligar fluxos da solução'
  inputs:
    targetType: 'inline'
    script: |
      $tenantId = "$(PowerPlatform.TenantId)"
      $appId    = "$(PowerPlatform.ApplicationId)"
      $secret   = "$(PowerPlatform.ClientSecret)"
      Add-PowerAppsAccount -TenantID $tenantId -ApplicationId $appId -ClientSecret $secret | Out-Null

      $envName = (Get-AdminPowerAppEnvironment | Where-Object {
        $_.Properties.linkedEnvironmentMetadata.instanceUrl -eq "$(BuildTools.EnvironmentUrl)"
      }).EnvironmentName

      # Pegue só os flows da solução que você está implantando (ajuste UniqueName se quiser filtrar)
      $flows = Get-AdminFlow -EnvironmentName $envName
      foreach($f in $flows){
        try{
          Enable-AdminFlow -EnvironmentName $envName -FlowName $f.FlowName -ErrorAction Stop
          Write-Host "Ligado: $($f.DisplayName)"
        } catch {
          Write-Warning "Não foi possível ligar $($f.DisplayName): $($_.Exception.Message)"
        }
      }
